# 一、了解SQL

**数据库**是一个以某种有组织的方式储存的数据集合

**数据库**保存有组织的数据的容器（通常是一个文件或一组文件）

**表**： 某种特定类型数据的结构化清单

 	 不能把不同的清单放在同一个表中  

​	 每张表在同一个数据库中的名字是唯一的

**列**： 	表由列组成，列中储存着表中某部分的信息

**数据类型**：	所容许的数据的类型。每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据

​			数据类型还帮助正确地排序数据，并在优化磁盘使用方面起重要作用

**行** ：	 表中的数据是按行储存的， 网格中垂直为列，水平为行

**备注：	**提到行（row）时称其为数据库记录(record)，这两个属于是可以互相替代的，但是，行才是正确

**主键：	** 一列或一组列，其值能够唯一区分表中每个行（**唯一表示表中每行的这个列（或这组列）成为主键**）

虽然，并不总是都需要主键，但大多数程序猿都应保证创建的每个表都具有一个主键，以便于以后的数据操纵和管理  			

​	**任意两行都不具有相同的的主键值，每个行都必须具有一个主键值（主键不能为NULL）**

**普遍认为的几个好习惯：**

​	**1，不更新主键列中的值**

​	**2，不重用主键列的值**

​	**3，不在主键列中使用可能会更改的值（列如，如果使用一个名字作为主键以标识某个供应商，当该供应商合并和更改其名字时，必须更改这个主键）**

**SQL：**是一种专门用来与数据库通信的语言

优点：	1，开放，使用所有数据库

​		2，SQL简单易学（全都是英文单词组成）

​		3，强有力，灵活的语言元素。

​	

# 二、MySQL简介

#### 1，什么是MySQL

​	优点：1，免费使用

​		 2，性能快

​		3，可信赖，大公司都在用

​		4，简单

​	用户--------->>客户机--------->> 服务器--------------->>数据库

#### 2，MySQL命令使用程序

​	可以直接在终端输入mysql就可以进入

​	个别需要输入

```
mysql -u root -p 
```

启动     -u 是用户登录    root 是用户名  -p 是使用密码登录  -h 服务器地址  -P 端口

​	用；结束

输入help或者\h获取帮助

quit或者exit



# 三、使用MySQL

#### 1,连接

主机名：localhost  或者   127.0.0.1

端口：默认3306

用户名

密码

列如：数据库名字movie

切换数据库:

```
use movie
```

显示数据库:

```
show databases
```

显示所有的表:

```
show tables
```

选择当前数据库可用的表

```
show columus from 表名
```

或者

```
describe  表明
```

支持的其他语言

```
show status 显示服务器状态
show create database/table  显示创建特定数据库或表的mysql语句
show grants 显示安全权限
show errors/warnings 显示服务器错误或警告
```

```
show help 显示所有允许的show语句
```



# 四、检索数据

#### 1，检索单列

```
select 列名 from 表
```

#### 2，检索多列

```
select 列名，列名，列名 from 表名
```

#### 3，检索所有

```
select * from 表名
```

#### 4，检索不同的行

```
select distinct 列 from 表名
```

distinct 不能被部分使用，除非都不同否则所有行都将检索

#### 5，限制结果

显示前数字个

```
select 列名 from 表名 limit 数字
```

显示从数字1开始，后面的数字2个

```
select 列名 from 表名 limit 数字1,数字2
或
select 列名 from 表名 limit 数字1 offset 数字2
```

检索的第一行是行0 不是行1

检索不够，直接返回能返回的行数

#### 6，使用完全限定表名

```
select 表名.行名 from 表名
select 表名.行名 from 数据库.表名
```



# 五、排序检索数据

不加排序条件，直接检索出来的顺序是无序的。

单列排序

```
select 列名 from 表名 order by 列名
```

多列排序

```
select 列名1, 列名2 from 表名 order by 列名1, 列名2
```

先按列名1的排序，不同时，才开始排列名2

指定排序方向

默认是升序，加了desc变为降序

```
select 列名1, 列名2 from 表名 order by 列名1, 列名2 desc
```

需要的后列名后面加desc

用limit要加在最后

```
select 列名1, 列名2 from 表名 order by 列名1, 列名2 desc limit 数字
```



# 六、数据过滤

1，where子句

```
select 列名1 from 表名 where 列名1 = 数字 
```

order by 要位于where之后

```
= 等于
<> 不等于
!= 不等于
< 小于
<= 小于等于
> 大于
>= 大于等于
BETWEEN 在指定的两个值之间
```

```
select 列名，列名 from 表 where 列名 != 数字    这种只能用！=
```



# 七、数据过滤

#### 1,and 操作符号

两个条件并列。

```
select 列1，列2 from 表 where 条件1 and 条件2
```

两个条件筛选。

每添一条过滤条件就要使用一个and

#### 2，or操作符号

两个条件有一个成立就行

```
select 列1，列2，列3 from 表 where 条件1 or 条件2
```

#### 3、计算次序

这种SQL不能判断

```
select 列1，列2，列3 from 表 where 条件1 or 条件2 and 条件3
```

必须加（）

```
select 列1，列2，列3 from 表 where (条件1 or 条件2) and 条件3
```

#### 4、in操作符

```
select 列1，列2 from 表 where in (起点，终点) order by 列1
```

in和or的功能差不多的

#### 5、not操作符

```
select 列1，列2 from 表 where not 条件
```

not可以和in 、between 和exists 



# 八、用通配符进行过滤

#### 1，like后跟通配符匹配

%表示任何字符出现任意次数

```
select 列1，列2 from 表 where 列 like ' 部分字符%'
```

这里要区分大小写。

例如

```
'abc%'	abc开头
'%abc'	abc结尾
'a%b'	a开头，b结尾
'%ab%'	无论哪里有ab
```

**不能匹配NULL**

#### 2、下划线通配符

_ 和%的用途是一样的。但是，_只能匹配单个字符

有几个_匹配多少个位置

```
select 列1，列2 from 表 where 列 like '_部分字符'
```

通配符比其他搜索所花的时间更长

1，不要过度使用通配符。

2，没必要的情况下，不要用在搜索的开始

3，确定通配符所在的位置，否则返回不是想要的数据



# 九、正则表达式进行搜索

#### 1，regexp 类型

regexp正则表达式

regexp的用法和like一样，但是，like是整行，regexp是包括行内值

```
select 列1，列2 from 表 where 列 regexp '部分字符'
```



#### 2，or 类型

两个中的任意一个符合

```
select 列1，列2 from 表 where 列 regexp '部分字符|部分字符'
```

还用几个加几个“|"分隔



#### 3，匹配几个字符之一

[一组字符] 和|功能是一样的。

```
select 列1，列2 from 表 where 列 regexp '[部分字符部分字符]'
相当于
select 列1，列2 from 表 where 列 regexp '[部分字符|部分字符]'
```

结果是相同的，但是没有加[ ]，结果就不一样了

```
select 列1，列2 from 表 where 列 regexp '[^部分字符部分字符]'  #匹配非
```

#### 4，匹配范围

```
[0-9]   [a-z]   [A-Z]  
```

不要哪个，单独的踢出来不写

#### 5,特殊字符

```
select 列1，列2 from 表 where 列 regexp '\\.'
```

表示查找"."，'\\\'表示查找全部

```
\\f		换页
\\n 	换行
\\r 	回车
\\t		制表
\\v		纵向制表
```

**多数正则表达式是一个"\"，但是MySQL要求两个"\\\"**

#### 6,匹配字符类

```
类 				说 明
[:alnum:] 任意字母和数字（同[a-zA-Z0-9]）
[:alpha:] 任意字符（同[a-zA-Z]）
[:blank:] 空格和制表（同[\\t]）
[:cntrl:] ASCII控制字符（ASCII 0到31和127）
[:digit:] 任意数字（同[0-9]）
[:graph:] 与[:print:]相同，但不包括空格
[:lower:] 任意小写字母（同[a-z]）
[:print:] 任意可打印字符
[:punct:] 既不在[:alnum:]又不在[:cntrl:]中的任意字符
[:space:] 包括空格在内的任意空白字符（同[\\f\\n\\r\\t\\v]）
[:upper:] 任意大写字母（同[A-Z]）
[:xdigit:] 任意十六进制数字（同[a-fA-F0-9]）
```

#### 7，匹配多个实例

```
元 字 符 				说 明
* 					0个或多个匹配
+				 1个或多个匹配（等于{1,}）
? 				0个或1个匹配（等于{0,1}）
{n}				 指定数目的匹配
{n,} 			不少于指定数目的匹配
{n,m} 			匹配数目的范围（m不超过255）
```

#### 8,定位符

```
^ 文本的开始
$ 文本的结尾
[[:<:]] 词的开始
[[:>:]] 词的结尾
```

开始

```
select 列1，列2 from 表 where 列 regexp '^[部分字符部分字符]'  
```



# 十、创建计算字段

#### 1，计算字段

储存在数据库中的数据一般不是应用程序所需要的格式。

可以在SQL语句内完成转换和格式化处理，也可以在客户机上完成，但是，在数据库中完成比在客户机上完成快很多

#### 2，拼接字段

将值链接在一起构成一个单值，在SQL的select中，可使用concat（）函数来拼接两个列

```
select concat(列名1，列名2) from 表名
```

可以去除空格

```
select concat(Trim(列名1)，Trim（列名2)） from 表名
```

RTrim()去除右空格，LTrim()去除左空格

#### 3，使用别名

如果要查看结果可以，但是，一个未别名的列不能用于客户机应用中，因为客户机没有办法引用它。

我们别名as关键字赋予

```
select concat(列名1，列名2) as 别名 from 表名
```

别名，也叫导出列

#### 4，执行计算

```
select 列1，列2，列1*列2 as 列名 from 表名
```



# 十一，使用数据处理函数

#### 1，函数

代码是具有可移植性的。不同的DBMS上有SQL相差不大，但是函数的可移植性不强，不同的DBMS差异较大。

#### 2，文本处理函数

```
select 列1，Upper(列1) as 列名 from 表
```



```
函 数		 说 明
Left() 		返回串左边的字符
Length()		 返回串的长度
Locate() 		找出串的一个子串
Lower() 		将串转换为小写
LTrim() 		去掉串左边的空格
Right()		 返回串右边的字符
RTrim() 		去掉串右边的空格
Soundex() 	返回串的SOUNDEX值
SubString()	 返回子串的字符
Upper()		 将串转换为大写
```



SOUNDEX需要做进一步的解释。SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。SOUNDEX考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。虽然SOUNDEX不是SQL概念，但MySQL（就像多数DBMS一样）都提供对SOUNDEX的支持。

```
select 列1，列2 from 表 where soundex('列2')=soundex('搜索内容')
```

这里是发音相似搜索



#### 3，日期和事件处理函数

常用的日期和事件处理函数

```
AddDate() 增加一个日期（天、周等）
AddTime() 增加一个时间（时、分等）
CurDate() 返回当前日期
CurTime() 返回当前时间
Date() 返回日期时间的日期部分
DateDiff() 计算两个日期之差
Date_Add() 高度灵活的日期运算函数
Date_Format() 返回一个格式化的日期或时间串
Day() 返回一个日期的天数部分
DayOfWeek() 对于一个日期，返回对应的星期几
Hour() 返回一个时间的小时部分
Minute() 返回一个时间的分钟部分
Month() 返回一个日期的月份部分
Now() 返回当前日期和时间
Second() 返回一个时间的秒部分
Time() 返回一个日期时间的时间部分
Year() 返回一个日期的年份部分
```



```
select 列1，列2 from 表 where data(列)='2005-09-01'
```

搜索本月所有的内容

```
select 列1，列2 from 表 where data(列) between '2018-09-01' and '2018-09-30'
```

或者

```
select 列1，列2 from 表 where year(列)=2018 and month(列)=9
```



#### 4，数值处理函数

```
函 数 	说 明
Abs()	 	返回一个数的绝对值
Cos() 		返回一个角度的余弦
Exp()		 返回一个数的指数值
Mod()	 	返回除操作的余数
Pi() 		返回圆周率
Rand() 		返回一个随机数
Sin() 		返回一个角度的正弦
Sqrt() 		返回一个数的平方根
Tan() 		返回一个角度的正切
```





# 十二、汇总数据

#### 1，聚集函数（运行在行组上，计算和返回单个值的函数）

有时候，我们只用检索总数据，不用具体检索出来，比如：

​	1，确定表中行数（或者满足某个条件或包含某个特定值的行数）

​	2，获得表中行组的和

​	3，找出表列（或所有行或某些特定的行）的最大值、最小值和平均值

```
函 数 		说 明
AVG() 		返回某列的平均值
COUNT() 	返回某列的行数
MAX() 		返回某列的最大值
MIN()		 返回某列的最小值
SUM()		 返回某列值之和
```

##### 1.1 avg()

```
select avg(列名或者行名) as 新列名 from 表
```

使用列名作为函数参数给出，要获得多个列的平均值，必须使用多个avg

NULL：avg（）函数忽略列值为null的行

##### 1.2，count（）函数

count(*)表中所有行进行计数，**不管表中包含是空值（NULL)还是非空值**

count(column)特定的行进行计数   **忽略NULL**

对所有：

```
select count(*) as 新名称 from 表
```

对列：

```
select count(列) as 新名称 from 表
```

##### 1.3 min(),max()

最大最小值

```
select max/min(列) as 新列名 from 表
```

**自动忽略NULL**的行

如果是按特定的行，那么就是最后/最前(max/min)一行

##### 1.4 sum()

```
select sum(行) as 新列名 from 表 where 条件
```

**自动忽略NULL**的行



#### 2，聚集不同值

**distinct**这个只能MySQL 5 以上的版本，5以下版本不支持   all是默认参数，不指定distinct 假定为all

2.1 

```
selet avg(distinct 列) as 新列名 from 表 where 条件
```

只计算不同的值

如果指定列名，只能用count（），不能用count（*），不能用于计算或表达式

#### 3，组合聚集函数

select 可根据需要包含多个聚集函数

```
select count(*) as 新列名 ,
	min(列名) as 新列名，
	max(列名) as 新列名，
	avg(列名) as 新列名，
from 表
```



# 十三，分组数据

#### 1，创建分组

group by

```
select 列1 ，列 as 新列名 from 表 group by 列1 
```

**注意事项**：

​	·group by 可以包含任意数目的列

​	·group by中嵌套分组，最后数值全部取回，不能单个取回

​	·group by 子句每个列必须是检索列和有效表达式，子句后跟相同表达式，	不能使用别名

​	·除了聚集计算，每个列必须在group by子句中给出

​	·如果分组中有null，则作为分组返回，如果是多行，则分为一组

​	·group by 子句必须出现在where子句之后，order by之前



每个分组以及分组汇总级别的值

```
select 列1 ，列 as 新列名 from 表 group by 列1 with rollup    
```



#### 2，过滤分组

having过滤分组，where只能过滤行。

having支持where的所有操作符

```
select 列1，列 as 新列名 from 表 group by 列 having 过滤条件
```

having和where并用

```
select 列1，列2 as 新列名 from 表 where 条件1 group by 列 having 条件2
```

#### 3，分组和排序

```
	ORDER BY 					GROUP BY 
排序产生的输出 				分组行。但输出可能不是分组的顺序
任意列都可以使用（甚至				只可能使用选择列或表达式列，而且必须使用每个选择
非选择的列也可以使用）				列表达式
不一定需要 						如果与聚集函数一起使用列（或表达式），则必须使用
```

用group by 的子句用order by来排序的唯一方法

```
select 列1 列2 as 新列名 from 表 group by 列 having 条件 order by 列
```

#### 4，select 顺序

```
子 句 		说 明 			是否必须使用
SELECT 		要返回的列或表达式 		是
FROM 		从中检索数据的表 		仅在从表选择数据时使用
WHERE		 行级过滤				 否
GROUP BY 		分组说明 		仅在按组计算聚集时使用
HAVING 			组级过滤 			否
ORDER BY 		输出排序顺序 			否
LIMIT			 要检索的行数			 否
```



# 十四、使用子查询

#### 1，利用子查询过滤

简单查询

```
select 列 from 表 where 条件
```

子查询

```
select 列 from 表 where (select 列 from 表 where 条件)
```

子查询，没有限制，但是由于性能问题，不要过多。

使用子查询必须保证select和where子句相同的数目

子查询一般和in连用，但是也可以用，= 和 <>

#### 2,作为计算字段使用子查询

````
select 列1 ，列2 ，(select 列 from 表 where 条件) as 新列名 from 表 order by 列
````

条件当中，必须匹配限定列名。

内查询快于外查询



# 十五、联结表

#### 1，关系表

主键：能表示唯一的标识

外键：外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系

关系型数据库比非关系型数据库可伸缩性强。

**可伸缩性**：能够是响应不断增加的工作量而不失败，设计良好的数据库或应用程序称之为可伸缩性好

#### 2，为什么要使用联结

联结是一种机制，用来在一条select语句中关联表，因此称之为联结。



#### 3，创建联结

简单创建

```
select 列1，列2，列3 from 表1，表2 where 表1主 =表2主 
```

#### 4，笛卡尔积(又称为叉联结)

由没有联结条件的表关系返回的结果为笛卡尔积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数

```
select 列1，列2，列3 from 表1，表2
```

#### 5，内部联结

基于两个表之间的相等测试称为 **等值联结**，也称为**内部联结**

```
select 列1，列2，列3 from 表1 inner join 表2 on 表1主=表2主
```

规范建议使用inner join 

#### 6，联结多个表

```
select 列1，列2，列3 ，列4 from 表1，表2，表3 where 表1=表2 and 表1 =表3 
```

子查询可以用联结多个表的方式来实现。



# 十六、创建高级联结

#### 1，使用表别名

别名：除了用于列名和计算字段外，还可以给表别名，主要因为：

​		1，缩短SQL语句

​			2，允许在单条SELECT语句中多次使用相同的表 

```
select 列1，列2 from 表1 as 新列名1 ，表2 as 新列名2 ，表3 as 新列名3 where 表1主 = 表2主 and 表1主 = 表3主 
```



#### 2，使用不同类型的联结

##### 2.1 自联结

使用相同的表

```
select 列1 ，列2 from 表1 where 列1 = （select 列3 from 表1 where 列1 = 某个值)
```

使用表别名的主要原因之一是能在单条SELECT语句中不 止一次引用相同的表。 

自联结

```
select p1.列1，p1.列2 from 表1 as p1 ，表1 as p2 where p1.列1 = p2.列1 and p2.列1=某个值
```

的第一次出现为别名p1 ，第二次出现为别名p2 。SELECT语 句使用p1前缀明确地给出所需列的全名 。即使它们事实上是同一个列 ，MySQL不知道想 要的是哪一个列 ，WHERE（通过匹配p1中 的列1和p2中的列1）首先联结两个表，然后按第二个表中的 列1过滤数据，返回所需的数据。 

**用自联结而不用子查询** 

有时候处理联结远比处理子查询快得多。 

##### 2.2 自然联结

有一个列出现在不止一个表中 ,自然联结排除多次出现，使每个列只返回一次 

自然联结是这样一种联结，其中你只能选择那些唯一的列。这一 般是通过对表使用通配符（SELECT *），对所有其他表的列使用明确的子 集来完成的。 

```
select A.* ,B.列1，C.列2 from 表1 as A ，表2 as B ，表3 as C where 表1主 =表2主 and 表3主 = 表2主 and 条件
```

在这个例子中，通配符只对第一个表使用。所有其他列明确列 出，所以没有重复的列被检索出来。 

迄今为止我们建立的每个内部联结都是自然联结，很可能 我们永远都不会用到不是自然联结的内部联结。 

##### 2.3 外部联结

许多联结将一个表中的行与另一个表中的行相关联 

```
select 表1.列1， 表2.列2 from 表1 left out join orders on 表1主=表2主
```

这条SELECT语句使用了关 键字OUTER JOIN来指定联结的类型（而不是在WHERE子句中指 定）。但是，与内部联结关联两个表中的行不同的是，外部联结还包括没 有关联行的行。在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字 指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT 指出的是OUTER JOIN左边的表）。上面的例子使用LEFT OUTER JOIN从FROM 子句的左边表（customers表）中选择所有行。为了从右边的表中选择所 有行，应该使用RIGHT OUTER JOIN 

```
select 表1.列1， 表2.列2 from 表2 left out join orders on 表1主=表2主
```



```
没有*=操作符 MySQL不支持简化字符*=和=*的使用，这两种操作符在其他DBMS中是很流行的。
```

它们之间的唯一差别是所关联的表的顺序不 同。 

究竟使用哪一种纯粹是根据方便而定。 

##### 2.4 使用带聚集函数的联结 

虽然至今为止聚集函数 的所有例子只是从单个表汇总数据，但这些函数也可以与联结一起使用。 

```
select 表1.列1 ,表2.列2 from 表1 left out join 表2 on 表1主=表2主 
```



#### 3.使用联结和联结条件

 注意所使用的联结类型。一般我们使用内部联结，但使用外部联 结也是有效的。

  保证使用正确的联结条件，否则将返回不正确的数据。 

 应该总是提供联结条件，否则会得出笛卡儿积。

  在一个联结中可以包含多个表，甚至对于每个联结可以采用不同 的联结类型。虽然这样做是合法的，一般也很有用，但应该在一 起测试它们前，分别测试每个联结。这将使故障排除更为简单 



# 十七、 组合查询

MySQL也允许执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compound query）。

两种基本情况，其中需要使用组合查询：

 在单个查询中从不同的表返回类似结构的数据
 对单个表执行多个查询，按单个查询返回数据

#### 1，使用union

```
select 列1 ，列2 from 表1 where 条件1 union select 列1 ，列2 from 表1 where 条件2 
```

**去除重复的行是默认行为，取消去除行为使用union all**

order by 必须在select 之后

UNION指示MySQL执行两条SELECT语句，并把输出组合成单个查询结果集。

但对于更复杂的过滤条件，或者从多个表（而不是单个表）中检索数据的情形，使用UNION可能会使处理更简单

#### 2，使用union规则

 UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合4条SELECT语句，将要使用3个UNION关键字）。
 UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过各个列不需要以相同的次序列出）。
 列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。
如果遵守了这些基本规则或限制，则可以将并用于任何数据检索

#### 3，对结果排序

```
select 列1 ，列2 from 表1 where 条件1 union select 列1 ，列2 from 表1 where 条件2 order by 排序条件
```



# 十八、全文本搜索

#### 1，理解全文本搜索

 性能——通配符和正则表达式匹配通常要求MySQL尝试匹配表中所有行（而且这些搜索极少使用表索引）。因此，由于被搜索行数不断增加，这些搜索可能非常耗时。

 明确控制——使用通配符和正则表达式匹配，很难（而且并不总是能）明确地控制匹配什么和不匹配什么。例如，指定一个词必须匹配，一个词必须不匹配，而一个词仅在第一个词确实匹配的情况下才可以匹配或者才可以不匹配。

 智能化的结果——虽然基于通配符和正则表达式的搜索提供了非常灵活的搜索，但它们都不能提供一种智能化的选择结果的方法。例如，一个特殊词的搜索将会返回包含该词的所有行，而不区分包含单个匹配的行和包含多个匹配的行（按照可能是更好的匹配来排列它们）。类似，一个特殊词的搜索将不会找出不包含该词但包含其他相关词的行。

#### 2，启动使用全文本搜索

创建表的时候，创建text格式的行，并且在创建语句中指定  fulltext（行名）

#### 3，进行全文本搜索

```
select 文本列 from 表 where match(文本列) against('内容')
```

match自带出现排序。不区分大小写，按优先级返回

#### 4，扩展查询

```
select 文本列 from 表 where match(文本列) against('内容' with query expansion)
```

#### 5，布尔文本搜索

 要匹配的词；
 要排斥的词（如果某行包含这个词，则不返回该行，即使它包含
其他指定的词也是如此）；
 排列提示（指定某些词比其他词更重要，更重要的词等级更高）；
 表达式分组；
 另外一些内容。

这个没有fulltext的索引也可以用

```
select 文本列 from 表 where match(文本列) against('内容' in boolean mode);
```

**搜索性能随数据量的增加而降低**

搜索，包含A 不包含B

```
select 文本列 from 表 where match(文本列) against('A -B' in boolean mode);
```



```
+ 			包含，词必须存在
- 			排除，词必须不出现
>			包含，而且增加等级值
< 			包含，且减少等级值
() 			把词组成子表达式（允许这些子表达式作为一个组被包含、排除、排列等）
~ 			取消一个词的排序值
* 			词尾的通配符
"" 			定义一个短语（与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语）
```



特别：

A   B 其中一个就行

```
select 文本列 from 表 where match(文本列) against('A B' in boolean mode);
```

A B 同时存在的

```
select 文本列 from 表 where match(文本列) against('"A B"' in boolean mode);
```



#### 6、全文搜索说明

 在索引全文本数据时，短词被忽略且从索引中排除。短词定义为那些具有3个或3个以下字符的词（如果需要，这个数目可以更改）。
 MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略。如果需要，可以覆盖这个列表（请参阅MySQL文档以了解如何完成此工作）。
 许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此，MySQL规定了一条50%规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。50%规则不用于IN BOOLEAN MODE。

 如果表中的行数少于3行，则全文本搜索不返回结果（因为每个词或者不出现，或者至少出现在50%的行中）。
 忽略词中的单引号。例如，don't索引为dont。
 不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。
 如前所述，仅在MyISAM数据库引擎中支持全文本搜索。



# 十九、插入数据

#### 1，插入完整的行

```
inset into 表 values('值'，'值');
```

不产生输出，但是这种简单但是很不安全，依赖顺序`

```
inset into 表(列1，列2) values('值'，'值');
```

安全，但是要繁琐一些

可以省略列，但是，前提必须允许为NULL或者有默认值

INSERT操作可能很耗时（特别是有很多索引需要更新时），而且它可能降低等待处理的SELECT语句的性能。

如果数据检索是最重要的（通常是这样），则你可以通过在INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级

```
inset low_priority into
```

也适用于update 和delete



#### 2，插入多行

```
inset into 表(列1，列2) values('值'，'值')('值'，'值');
```

#### 3，插入检索出的数据

INSERT还存在另一种形式，可以利用它将一条SELECT语句的结果插入表中。

```
inset into 表1(列1，列2) select 列3，列4 from 表2
```

备注：主键值重复，可能会失败，所以，可以忽略，自动生成

可以添加where

```
inset into 表1(列1，列2) select 列3，列4 from 表2 where 条件
```



# 二十、更新和删除数据

#### 1，更新数据

```
updata 表 set 列 = '值' where 条件
```

更新多行

```
updata 表 set 列 = '值', 列 = '值' where 条件
```

更新多行时，如果出现错误，错误发生前更新的数据会恢复它们原来的值

即使发生错误，继续进行更新的时候，可以使用

```
updata ignore 表 set 列 = '值', 列 = '值' where 条件
```



#### 2，删除数据



```
delete from 表 where 条件
```



#### 3，注意事项

除非确实打算每一行，否则不要使用不带where的updata和delete

更新和删除之前，可以先用select确定一下

确认更改数据，因为SQL没有撤销功能



# 二十一、创建和操纵表

#### 1，创建表

可以使用交互性创建和管理表的工具，也可以使用mysql语句创建

```
create table 表名
(
	列名1	类型	NULL/NOT NULL，
	列名2	类型	NULL/NOT NULL，
	primary key （列名）
)
```

默认是为NULL的

#### 2，主键再介绍

主键值必须唯一

```
primary key(列名)
```

多个列为主键时，用‘，’隔开

#### 3，使用auto_increment

auto_increment告诉MySQL，每增加一行时，自动增量。每个表只允许auto_increment列，而且，它必须被索引

#### 4，指定默认值

default 指定 默认的值 

#### 5，引擎类型

不同的引擎具有各自不同的功能和特性，为不同的任务选择正确的引擎能获得良好的功能和灵活性。

可以省略，默认MyISAM

 InnoDB是一个可靠的事务处理引擎（参见第26章），它不支持全文本搜索；
 MEMORY在功能等同于MyISAM，但由于数据存储在内存（不是磁盘）中，速度很快（特别适合于临时表）；
 MyISAM是一个性能极高的引擎，它支持全文本搜索（参见第18章），但不支持事务处理。

引擎类型可以混用

但是，外键不能跨引擎

#### 6，更新表

添加一列

```
alter table 表 add 新列名 类型
```

删除一列

```
alter table 表 drop column 列名
```

添加外键

```
alter table 表1 add constraint 列1 foreign key (外键值) references 表2（列2）
```



#### 7，删除表

```
drop table 表
```



#### 8，重命名表

```
rename table 表1 to 表2
```



# 二十二、使用视图

#### 1，视图

不包含表中应该有的任何列或数据，它包含的是一个SQL查询（以正确联结表的相同的查询）



#### 2，为什么使用视图

 重用SQL语句。
 简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必
知道它的基本查询细节。
 使用表的组成部分而不是整个表。
 保护数据。可以给用户授予表的特定部分的访问权限而不是整个
表的访问权限。
 更改数据格式和表示。视图可返回与底层表的表示和格式不同的
数据。

**性能问题** 因为视图不包含数据，所以每次使用视图时，都
必须处理查询执行时所需的任一个检索。如果你用多个联结
和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能
下降得很厉害。因此，在部署使用了大量视图的应用前，应
该进行测试



#### 3，视图的规则和限制

 与表一样，视图必须唯一命名（不能给视图取与别的视图或表相
同的名字）。

 对于可以创建的视图数目没有限制。

 为了创建视图，必须具有足够的访问权限。这些限制通常由数据
库管理人员授予。

 视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造
一个视图。

 ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也
含有ORDER BY，那么该视图中的ORDER BY将被覆盖。

 视图不能索引，也不能有关联的触发器或默认值。

 视图可以和表一起使用。例如，编写一条联结表和视图的SELECT
语句。



#### 4，使用视图

```
create view  	创建
show create view viewname 查看创建视图
drop view viewname 删除
create or replace view
```



#### 5，利用视图简化复杂的联结

```
create view 视图名 as select 列1，列2 from 表1，表2 where 表1.列1=表2.列2 and 表1.3=表2.列4
```

可以多次使用视图



#### 6，用视图重新格式化检索出的数据

```
create view 视图名 as select 列1 from 表1 where 条件1 order by 条件2
```



#### 7，使用视图与计算字段

```
create view 视图名 as select 列1，列2，列1*列2 as 新列名 from 表

#使用
select * from 视图名 where 条件
```

大部分的视图，是不能更新的



# 二十三、使用存储过程

#### 1，储存过程

存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理。

 通过把处理封装在容易使用的单元中，简化复杂的操作（正如前
面例子所述）。

 由于不要求反复建立一系列处理步骤，这保证了数据的完整性。
如果所有开发人员和应用程序都使用同一（试验和测试）存储过
程，则所使用的代码都是相同的。
这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能
性就越大。防止错误保证了数据的一

 简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）
有变化，只需要更改存储过程的代码。使用它的人员甚至不需要
知道这些

**优点**：1，提高性能，储存过程比单独的SQL语句快

​            2，能编程强大、灵活的代码

​	 	3，安全

#### 2，创建储存过程

```
create procedure 过程名() begin select avg(列名) as 新列名 from 表;end;
```



**注意**：如果命令行使用程勋要世界储存过程自身内的，字符，则最终不会成为储存过程的成分

```
#定义 //
delimiter //

create procedure 过程名() begin select avg(列名) as 新列名 from 表;end//
#回复;
delimiter;
```

除了/，其他的字符都可以

使用

```
call 过程名（）;
```



#### 3，删除储存过程

```
drop procedure 过程名
```

如果，过程名不存在，则会报错。

```
drop proccedure 过程名 if exists
```



#### 4，使用参数

一般，存储过程并不显示结果，而是把结果返回给你指定的变量

**变量**：内存中一个特定的位置，用来零食存储数据

一个参数不能返回多个行和列

创建

比如：

```
create procedure 过程名(out 参数1 decimal(数值)，out 参数 decimal(数值))
begin
	select min（列) into 参数 from 表；
end;
```

MySQL支持IN（传递给存储过程）、OUT（从存储过程传出，如这里所用）和INOUT（对存储过程传入和传出）类型的参数。

使用

```
call 过程名(@参数)
```

**MySQL变量必须用@开始**



显示检索

````
select @参数1，@参数2
````



带数字参数

```
create procedure 过程名(in 参数0 类型 out 参数1 decimal(数值)，out 参数 decimal(数值))
begin
	select min（列) into 参数 from 表；
end;
```

使用

```
call 过程名(参数 ，@参数)
```

查看

```
select @参数
```

最好网上再查一下

#### 5，建立智能储存过程

太难，没搞懂，自己网上查



#### 6、检查储存过程

```
show create procedure 过程名
```



# 二十四、使用游标

#### 1，游标

游标（cursor）是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。

作用：游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改

#### 2，创建游标

````
create procedure 过程名()
begin
	declare 游标名 cursor
	for
	select 列 from 表;
	end;
````

#### 3，打开、关闭图标

打开

```
open 游标名
```

关闭

```
close 游标名
```

MySQL将会到达end语句时自动关闭游标





# 有序后置如何，请耐心等待